epmsmail {
    app {
        tenants = [
            "RC100130",
            "SEPP.GAUG"
        ]
    }
    mail {
        inbox = "./inbox"
        RC100130 {
            domain = ${?EMAIL_DOMAIN}
            javaxmail {
                mail {
#                     debug = true
                    store.protocol = "imaps"
                    imap {
#                         ssl.enable = true
                        port = ${IMAP_EMAIL_PORT}
                        host = ${IMAP_SERVER_HOST}
                        ssl.trust = ${?IMAP_SERVER_HOST}
                        starttls.enable = true
                    }
                    smtp {
                        host = ${?SMTP_SERVER_HOST}
                        port = ${?SMTP_EMAIL_PORT}
                        starttls.enable = true
                        auth = true
                    }
                }
            }
            authenticator {
                username = ${?EMAIL_USER}
                password = ${?EMAIL_PASSWORD}
            }
        }
        SEPP.GAUG {
            domain = "gmail.com"
            javaxmail {
                mail {
#                     debug = true
                    store.protocol = "imaps"
                    imap {
                        ssl.enable = true
                        port = 993
                        host = "imap.gmail.com"
                        ssl.trust = "imap.gmail.com"
                        starttls.enable = true
                    }
                    smtp {
                        host = "smtp.gmail.com"
                        port = 587
                        starttls.enable = true
                        auth = true
                    }
                }
            }
            authenticator {
                username = "sepp.gaug@gmail.com"
                password = "iykznzjhjarykilx"
            }
        }
        edanet.at {
            javaxmail {
                mail {
                    store.protocol = "imap"
                    imap {
                        starttls.enable = true
                    }
                    smtp {
                        starttls.enable = true
                        auth = true
                    }
                }
            }
        }
        gmail.com {
            javaxmail {
                mail {
#                     debug = true
                    store.protocol = "imap"
                    imap {
                        ssl.enable = true
                        host = "imap.gmail.com"
                        starttls.enable = true
                    }
                    smtp {
                        host = "smtp.gmail.com"
                        starttls.enable = true
                        auth = true
                    }
                }
            }
        }
    }
    mqtt {
        url = "tcp://localhost:1883"
        topic = "eda/request"
        qos = 1
        consumer-id = "edash-mqtt-client"
        topics {
            energyTopic = "eda/response/energy"
            cmTopic = "eda/response/cm"
            cpTopic = "eda/response/cp"
            errorTopic = "eda/response/error"
        }
    }
}

slick.pgsql.local {
  dataSourceClass = "slick.jdbc.DatabaseUrlDataSource"
  driver = "slick.driver.PostgresDriver$"
  db {
    driver="org.postgresql.Driver"
    url="jdbc:postgresql://localhost:6432/postgresDB"
    user="postgresUser"
    password="postgresPW"
    queueSize=5000
    connectionTimeout=30000
    maxConnections=8
    minConnections=2
    numThreads=8
  }
}

logger.scala.slick.jdbc.JdbcBackend.statement=INFO
logging.level.com.zaxxer.hikari.HikariConfig=INFO
logging.level.com.zaxxer.hikari=INFO

# slick.pgsql.local.profile = "slick.driver.PostgresDriver"
#
# slick.driver.PostgresDriver = {
#       connectionPool = "HikariCP" //use HikariCP for our connection pool
#       dataSourceClass = "org.postgresql.ds.PGSimpleDataSource" //Simple datasource with no connection pooling. The connection pool has already been specified with HikariCP.
#       properties = {
#         serverName = "localhost"
#         portNumber = "6432"
#         databaseName = "postgresDB"
#         user = "postgresUser"
#         password = "postgresPW"
#       }
#       numThreads = 10
# }

akka {
  logger.scala.slick = "INFO"
  loglevel = "INFO"
  persistence.journal.plugin = "akka.persistence.journal.leveldb"
  persistence.snapshot-store.plugin = "akka.persistence.snapshot-store.local"

  persistence.journal.leveldb.dir = "storage/prod/journal"
  akka.persistence.snapshot-store.local.dir = "storage/prod/snapshots"

  akka.persistence.journal.leveldb.native = false

  actor {
    serialization-bindings {
      "at.energydash.actor.CborSerializable" = jackson-cbor
    }
  }
  quartz {
#     defaultTimezone = "Asia/Bangkok"
    schedules {
      Every3hours {
        description = "A cron job that fires off every 3 hours"
        expression = "0 0 */3 * * ? *"
      }
      Every1Minute {
        description = "A cron job run every 1 minute"
        expression = "* */1 * * * ? *"
      }
      Every10Seconds {
        description = "A cron job run every 10 second"
        expression = "*/10 * * * * ? *"
      }
      Notify {
        description = "Notify cron job"
        expression = "0 0 9,12,18,23 * * ? *"
        expression = ${?CRYPTO_NOTIFY_NOTIFY_CRON}
      }
      HealthCheck {
        description = "HealthCheck cron job"
        expression = "0 */30 * * * ? *"
        expression = ${?CRYPTO_NOTIFY_HEALTHCHECK_CRON}
      }
    }
  }
}